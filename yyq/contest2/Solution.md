# Solution
```
/******************
  开始编辑时间：  18:55 17/06/21
  结束编辑时间：  19:40 17/06/21

    VJudge链接：  https://cn.vjudge.net/contest/167220
CodeForces链接：  http://codeforces.com/contest/514

题目按CF顺序排序
******************/
```

***

## #A Chewbaсca and Number
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/167220#problem/B
CodeForces链接：  http://codeforces.com/contest/514/problem/A

      时间限制：  1s
      空间限制：  256MB
      主要算法：  模拟
******************/
```
### 题意
给一个数，求每位按（9-该位数）反过来后最大的数。
直接遍历，没啥讲。

***
## #B Han Solo and Lazer Gun
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/167220#problem/D
CodeForces链接：  http://codeforces.com/contest/514/problem/B

      时间限制：  1s
      空间限制：  256MB
      主要算法：  模拟
******************/
```
### 题意
给你枪的坐标，再给你几个要打的物品的坐标，问要几枪可以全部打完？
### 题解
遍历所有点，用set存每个点与枪坐标点的k值，再输出set的size就行了。
P.S. 注意当物品点和枪坐标点相同时加特判。

***
## #C Watto and Mechanism
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/167220#problem/E
CodeForces链接：  http://codeforces.com/contest/514/problem/C

      时间限制：  3s
      空间限制：  256MB
      主要算法：  哈希+暴力
******************/
```
### 题意
给出n个字符串，存在Mechanism的内存里，接下来给出m个字符串，问可不可以改变每个字符串的某一个字母来与内存中的字符串相等，可以输出“YES”，否则输出“NO”。
### 题解
可以发现我们可以将前n个字符串先进行哈希存入set，再将后m个字符串哈希，在遍历改变某个字符时对哈希值进行改变，若set中存在这个哈希值，就是“YES”，若遍历完还是找不到对应的哈希值，就输出“NO”。
### Note
这题有坑点。对于哈希的mod，要取得巧妙一些，否则容易使哈希值重复导致WA。
P.S. 我取的mod值为1000000000000000007。

***
## #D R2D2 and Droid Army
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/167220#problem/C
CodeForces链接：  http://codeforces.com/contest/514/problem/D

      时间限制：  2s
      空间限制：  256MB
      主要算法：  二分答案+线段树
******************/
```
### 题意
一个军队中有n个机器人，每个机器人有m个数值。你一共可以射击k次，每次可以将一段机器人的某一个值减1，若机器人的m个值均为0后，这个机器人就被破坏了。问在k次射击之内，最长可以破坏的机器人的队列的长度。
### 题解
用线段树保存m个数值的区间最大值。线段树查询区间最大值，二分死亡的机器人个数，枚举区间起点，区间m个值的最大值的和如果小于等于k则满足条件。

***
## #E Darth Vader and Tree
```
/******************
    VJudge链接：  https://cn.vjudge.net/contest/167220#problem/A
CodeForces链接：  http://codeforces.com/contest/514/problem/E

      时间限制：  1s
      空间限制：  256MB
      主要算法：  矩阵快速幂+DP
******************/
```
### 题意
给定n个边的数值d[i]，求x分解成子树（每条边为权值为d[i]）的总个数。
### 题解
首先我们可以得到dp方程dp[x] = dp[n-d[1]] + dp[n-d[2]]+...+dp[n-d[i]] + 1;但是x最大值有10e9,所以直接dp是不可行的。

但是这样还不够,以为i的范围很大,不能用单纯的for循环来求解,这时候应该想到利用矩阵来做矩阵快速幂. 

构造一个矩阵K使得[f[1],f[2],f[3],...,f[100]]*K=[f[2],f[3],f[4],...,f[101]].要能够快速幂K肯定是个正方形矩阵.所以可以大致得到上面的矩阵公式.然后下面就是构造K矩阵的问题了. 

由

f[2]=f[1]*c[1]+1

f[3]=f[1]*c[2]+f[2]*c[1]+1
  
.....
  
f[101]=f[1]*c[100]+f[2]*c[99]+…+f[100]*c[1]+1
  
易知K的初步构造如下: 
  
c1  c2  c3  ... c100

 0  c1  c2  ... c99
 
 0   0  c1  ... c98
 
... ... ... ... ...

 0   0   0   0  c1
 
显然这样还不够,因为缺少了公式最后的”+1”,假设原矩阵是A*K=B的话,令A多一列变为[A,1],令K多一行一列,则K应该变为: 

c1  c2  c3  ... c100 0

 0  c1  c2  ... c99  0
 
 0   0  c1  ... c98  0
 
... ... ... ... ...  0

 0   0   0   0  c1   0
 
 1   1   1   1   1   1
 
然后A*K=B的矩阵就构造完成了[f[1],f[2],f[3],...,f[100],1]*K=[f[2],f[3],f[4],...,f[101],1].要求Fn,则计算A∗Kn−100即可.
